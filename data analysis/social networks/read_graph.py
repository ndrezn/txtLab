## Social network analysis on the graphs generated by editor_graphs.py

from igraph import *


def main():
	file = "/Volumes/KINGSTON/txtlab/out/social networks/graphs/all.GraphML"
	g = load(file)
	
	dendrograms = {}
	clusters = {}
	## Community structure based on the greedy optimization of modularity. This algorithm
	## merges individual nodes into communities in a way that greedily maximizes the modularity 
	## score of the graph. It can be proven that if no merge can increase the current modularity
	## score, the algorithm can be stopped since no further increase can be achieved.
	## This algorithm is said to run almost in linear time on sparse graphs.
	dendrograms['fastgreedy'] = g.community_fastgreedy(weights = [weight for weight in g.es['weight']])
	print('Done fastgreedy.')
	
	## Community structure based on the betweenness of the edges in the network. The idea is that 
	## the betweenness of the edges connecting two communities is typically high, as many of the 
	## shortest paths between nodes in separate communities go through them. So we gradually remove
	## the edge with the highest betweenness and recalculate the betweennesses after every removal. 
	## This way sooner or later the network falls of to separate components. The result of the 
	## clustering will be represented by a dendrogram.
	dendrograms['edge_betweenness'] = g.community_edge_betweenness(weights = [weight for weight in g.es['weight']])
	print('Done edge_betweenness.')

	## Community detection algorithm of Latapy & Pons, based on random walks. The basic idea of
	## the algorithm is that short random walks tend to stay in the same community. The result
	## of the clustering will be represented as a dendrogram.
	dendrograms['walktrap'] = g.community_walktrap(weights = [weight for weight in g.es['weight']])
	print('Done walktrap.')

	## Finds the community structure of the graph according to the spinglass community detection
	## method of Reichardt & Bornholdt.
	clusters['spinglass'] = g.community_spinglass(weights = [weight for weight in g.es['weight']])
	print('Done spinglass.')

	## This is a bottom-up algorithm: initially every vertex belongs to a separate community, 
	## and vertices are moved between communities iteratively in a way that maximizes the
	## vertices' local contribution to the overall modularity score. When a consensus is 
	## reached (i.e. no single move would increase the modularity score), every community in 
	## the original graph is shrank to a single vertex (while keeping the total weight of the 
	## adjacent edges) and the process continues on the next level. The algorithm stops when it 
	## is not possible to increase the modularity any more after shrinking the communities to vertices.
	clusters['multilevel'] = g.community_multilevel(weights = [weight for weight in g.es['weight']])
	print('Done multilevel.')

	## Finds the community structure of the network according to the Infomap method of Martin
	## Rosvall and Carl T. Bergstrom.
	clusters['infomap'] = g.community_infomap(edge_weights = [weight for weight in g.es['weight']])
	print('Done infomap.')
	print()

	for kind, dendrogram in dendrograms.items():
		clusters[kind] = dendrogram.as_clustering()

	for kind, cluster in clusters.items():
		print(kind)
		for group in cluster:
		 	genres = {'films':0, 'tv':0,'novels':0}
		 	for node in group:
		 		genres[g.vs['genre'][node]] += 1
		 	print(genres)
		 print()


if __name__ == '__main__':
	main()