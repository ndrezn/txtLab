from igraph import *
from statistics import stdev, mean
import os
import operator


def louvain(g):
	## LOUVAIN ALGORITHM
	## This is a bottom-up algorithm: initially every vertex belongs to a separate community, 
	## and vertices are moved between communities iteratively in a way that maximizes the
	## vertices' local contribution to the overall modularity score. When a consensus is 
	## reached (i.e. no single move would increase the modularity score), every community in 
	## the original graph is shrank to a single vertex (while keeping the total weight of the 
	## adjacent edges) and the process continues on the next level. The algorithm stops when it 
	## is not possible to increase the modularity any more after shrinking the communities to vertices.
	louvain = g.community_multilevel(weights = [weight for weight in g.es['weight']])
	return louvain


def genre_purity(communities, graphs):
	# total number of groups with more than 50 nodes labeled either 'comedy' or 'drama'
	large_groups = 0
	# array to hold the purity scores for every community generated
	purity = []
	# dict to count the number of times each class is the majority
	max_types = {}

	for louvain, g in zip(communities, graphs):
		for group in louvain:
			genres = {}
			total_nodes = 0
			for node in group:	 		
				if ('comedy' == g.vs['genre'][node].lower()) or ('drama' == g.vs['genre'][node].lower()):
					total_nodes+=1
					if g.vs['genre'][node] in genres:
						genres[g.vs['genre'][node]] += 1
					else:
					 	genres[g.vs['genre'][node]] = 1

			if total_nodes < 50:
				continue
			large_groups+=1
			# purity score
			most = max(genres.values())
			max_type = max(genres.items(), key=operator.itemgetter(1))[0]
			if max_type in max_types:
				max_types[max_type] += 1
			else:
				max_types[max_type] = 1

			purity.append(most/total_nodes)
	
	return purity, large_groups, max_types


def get_median(medium):
	if medium == 'films':
		return 1950
	elif medium == 'novels':
		return 1989
	elif medium == 'tv':
		return 1999


def period_purity(communities, graphs):
	# total number of communities generated by all the louvain movels
	total_groups = 0
	# total number of groups with > 50 nodes
	large_groups = 0
	# array to hold the purity scores of every community generated
	purity = []
	max_types = {}
	avg_purity_by_type = {}

	for louvain,g in zip(communities, graphs):
		total_groups += len(louvain)
		for group in louvain:
			# dict to hold the number of nodes from each set in
			periods = {}
			total_nodes = len(group)
			
			# check the number of nodes in the group
			if total_nodes < 50:
				continue
			# count the number of groups being counted
			large_groups += 1

			for node in group:
				year = -1
				# get median
				if g.vs['year'][node] > get_median(g.vs['medium'][node]):
					year = 1
				else:
					year = 0
				
				# split into groups
				if year in periods:
					periods[year] += 1
				else:
				 	periods[year] = 1
			
			# majority period from the group
			most = max(periods.values())
			# number of times each type is the majority
			# max_type is the type of node (early or late) that is the strongest in a given community
			max_type = max(periods.items(), key=operator.itemgetter(1))[0]
			if max_type in max_types:
				max_types[max_type] += 1
				avg_purity_by_type[max_type].append(most/total_nodes)
			else:
				max_types[max_type] = 1
				avg_purity_by_type[max_type] = [most/total_nodes]
			# percentage of nodes from the group that are from the majority group
			purity.append(most/total_nodes)	


	return purity, large_groups, total_groups, max_types, avg_purity_by_type 	


def medium_purity(communities, graphs):
	# total number of communities generated by all the louvain movels
	total_groups = 0
	# total number of groups with > 50 nodes
	large_groups = 0
	# array to hold the purity scores of every community generated
	purity = []
	max_types = {}
	for louvain,g in zip(communities, graphs):
		total_groups += len(louvain)
		for group in louvain:
			# dict to hold the number of nodes from each set in
			mediums = {}
			total_nodes = len(group)
			
			# check the number of nodes in the group
			if total_nodes < 50:
				continue
			# count the number of groups being counted
			large_groups += 1

			for node in group:
				# split into groups
				if g.vs['medium'][node] in mediums:
					mediums[g.vs['medium'][node]] += 1
				else:
				 	mediums[g.vs['medium'][node]] = 1
			
			# majority period from the group
			most = max(mediums.values())
			# number of times each type is the majority
			max_type = max(mediums.items(), key=operator.itemgetter(1))[0]
			if max_type in max_types:
				max_types[max_type] += 1
			else:
				max_types[max_type] = 1
			# percentage of nodes from the group that are from the majority group
			purity.append(most/total_nodes)	

	return purity, large_groups, total_groups, max_types	


def main():
	kind = 'novels'
	print(kind)

	directory = "/Volumes/NATHAN/out/social networks/random_samples/"+kind+"/"

	file_list = [f for f in os.listdir(directory) if not f.startswith('.')]

	files = [(directory+file) for file in file_list]

	communities = []
	graphs = []
	for file in files:
		g = load(file)
		graphs.append(g)
		communities.append(louvain(g))

	if 'all_mediums_small' in kind or "all_mediums" in kind:
		score, large_groups, total_groups, max_types = medium_purity(communities, graphs)
		print("Average medium purity: " + str(mean(score)))
		print("Stdev. medium: " + str(stdev(score)))

		print("Medium large groups: " + str(large_groups))
		print("Medium division of majorities: " + str(max_types))

		print("Total groups: " + str(total_groups))


	period_score, period_large_groups, period_total_groups, period_max_types, purity_by_type = period_purity(communities, graphs)

	for key,value in purity_by_type.items():
		purity_by_type[key] = mean(value)

	print("Average period purity: " + str(mean(period_score)))
	print("Stdev. period: " + str(stdev(period_score)))

	print("Period large groups: " + str(period_large_groups))
	print("Period division of majorities: " + str(period_max_types))
	print("Purity by class: " + str(purity_by_type))

	print("Total groups: " + str(period_total_groups))

	if 'all_mediums' in kind:
		exit()

	if 'novels' not in kind:
		genre_score, genre_large_groups, genre_max_types = genre_purity(communities, graphs)

		print("Average genre purity: " + str(mean(genre_score)))
		print("Stdev. genre: " + str(stdev(genre_score)))

		print("Genre large groups: " + str(genre_large_groups))
		print("Genre division of majorities: " + str(genre_max_types))

if __name__ == '__main__':
	main()